import tkinter as tk
from tkinter import ttk, messagebox
import hashlib
import struct

# ==========================================
#  Custom Hash Algorithm (Toy Educational)
# ==========================================
def rotl32(x, r):
    return ((x << r) & 0xFFFFFFFF) | (x >> (32 - r))

def toy_hash(plaintext: str, out_len_hex=32) -> str:
    data = plaintext.encode('utf-8')
    s0, s1, s2, s3 = 0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344
    state = [s0, s1, s2, s3]
    primes = [0x9E3779B1, 0x85EBCA6B, 0xC2B2AE35]
    block_size = 8

    for i in range(0, len(data), block_size):
        block = data[i:i + block_size]
        if len(block) < block_size:
            block = block + b'\x80' + b'\x00' * (block_size - len(block) - 1)
        m0 = struct.unpack_from('<I', block, 0)[0]
        m1 = struct.unpack_from('<I', block, 4)[0]

        state[0] = (state[0] + (m0 ^ primes[0])) & 0xFFFFFFFF
        state[1] = (state[1] ^ (m1 + primes[1])) & 0xFFFFFFFF
        state[2] = (state[2] + rotl32(state[0] ^ m1, 7)) & 0xFFFFFFFF
        state[3] = (state[3] ^ rotl32(state[1] + m0, 11)) & 0xFFFFFFFF
        state[0] ^= ((state[0] << 5) & 0xFFFFFFFF) ^ (state[1] >> 3)
        state[1] = (state[1] + ((state[2] << 7) & 0xFFFFFFFF)) & 0xFFFFFFFF
        state[2] ^= state[3] ^ primes[2]
        state[3] = (state[3] + state[0]) & 0xFFFFFFFF

    for _ in range(6):
        a, b, c, d = state
        a = (a ^ rotl32(b + primes[0], 3) + ((c >> 5) | (d << 27))) & 0xFFFFFFFF
        b = (b + rotl32(c ^ primes[1], 7) ^ ((d << 11) & 0xFFFFFFFF)) & 0xFFFFFFFF
        c = (c ^ rotl32(d + primes[2], 13) + (a >> 2)) & 0xFFFFFFFF
        d = (d + rotl32(a ^ primes[0], 17) ^ (b >> 3)) & 0xFFFFFFFF
        state = [a, b, c, d]

    digest_bytes = b''.join(struct.pack('<I', w) for w in state)
    return digest_bytes.hex()[:out_len_hex]

def hamming_distance_bits(a_hex, b_hex):
    a_bits = bin(int(a_hex, 16))[2:].zfill(len(a_hex) * 4)
    b_bits = bin(int(b_hex, 16))[2:].zfill(len(b_hex) * 4)
    return sum(x != y for x, y in zip(a_bits, b_bits))

# ==========================================
#  GUI: Mode Switching
# ==========================================
def show_main_menu():
    clear_window()
    ttk.Label(root, text="ðŸ” Custom Hash Function Demo", font=("Segoe UI", 16, "bold")).pack(pady=20)
    ttk.Label(root, text="Select an option to continue:", font=("Segoe UI", 12)).pack(pady=10)
    ttk.Button(root, text="ðŸ§© Test Single Hash", command=show_single_hash_ui).pack(pady=10, ipadx=10)
    ttk.Button(root, text="âš–ï¸ Compare Two Hashes", command=show_compare_ui).pack(pady=10, ipadx=10)
    ttk.Label(root, text="(Educational use only â€” not cryptographically secure)", foreground="gray").pack(pady=30)

def clear_window():
    for widget in root.winfo_children():
        widget.destroy()

# ==========================================
#  Mode 1: Single Hash Interface
# ==========================================
def show_single_hash_ui():
    clear_window()
    ttk.Button(root, text="â¬… Back", command=show_main_menu).pack(anchor="nw", padx=10, pady=10)
    ttk.Label(root, text="Single Input Hash Mode", font=("Segoe UI", 15, "bold")).pack(pady=10)

    ttk.Label(root, text="Enter text to hash:").pack(pady=5)
    text_box = tk.Text(root, height=5, width=90)
    text_box.pack(pady=5)

    output_custom = tk.Text(root, height=2, width=90)
    output_sha = tk.Text(root, height=2, width=90)

    def compute_single():
        text = text_box.get("1.0", "end").strip()
        if not text:
            messagebox.showwarning("Empty Input", "Please enter some text!")
            return
        custom_hash = toy_hash(text)
        sha_hash = hashlib.sha256(text.encode()).hexdigest()

        output_custom.delete("1.0", "end")
        output_custom.insert("end", custom_hash)
        output_sha.delete("1.0", "end")
        output_sha.insert("end", sha_hash)

    ttk.Button(root, text="Compute Hash", command=compute_single).pack(pady=10)

    ttk.Label(root, text="Custom Hash (Toy Algorithm):").pack(pady=3)
    output_custom.pack(pady=3)
    ttk.Label(root, text="SHA-256 Hash:").pack(pady=3)
    output_sha.pack(pady=3)

# ==========================================
#  Mode 2: Compare Two Inputs
# ==========================================
def show_compare_ui():
    clear_window()
    ttk.Button(root, text="â¬… Back", command=show_main_menu).pack(anchor="nw", padx=10, pady=10)
    ttk.Label(root, text="Compare Two Inputs", font=("Segoe UI", 15, "bold")).pack(pady=10)

    ttk.Label(root, text="Input Text 1:").pack(pady=5)
    text1 = tk.Text(root, height=4, width=90)
    text1.pack(pady=5)
    ttk.Label(root, text="Input Text 2:").pack(pady=5)
    text2 = tk.Text(root, height=4, width=90)
    text2.pack(pady=5)

    output_custom_1 = tk.Text(root, height=2, width=90)
    output_custom_2 = tk.Text(root, height=2, width=90)
    output_sha_1 = tk.Text(root, height=2, width=90)
    output_sha_2 = tk.Text(root, height=2, width=90)
    ham_custom_label = ttk.Label(root, text="", foreground="blue", font=("Segoe UI", 11, "bold"))
    ham_sha_label = ttk.Label(root, text="", foreground="green", font=("Segoe UI", 11, "bold"))

    def compute_compare():
        t1, t2 = text1.get("1.0", "end").strip(), text2.get("1.0", "end").strip()
        if not t1 or not t2:
            messagebox.showwarning("Empty Input", "Please enter text in both boxes!")
            return

        # Compute hashes
        h1_custom, h2_custom = toy_hash(t1), toy_hash(t2)
        h1_sha, h2_sha = hashlib.sha256(t1.encode()).hexdigest(), hashlib.sha256(t2.encode()).hexdigest()

        # Update outputs
        output_custom_1.delete("1.0", "end"); output_custom_1.insert("end", h1_custom)
        output_custom_2.delete("1.0", "end"); output_custom_2.insert("end", h2_custom)
        output_sha_1.delete("1.0", "end"); output_sha_1.insert("end", h1_sha)
        output_sha_2.delete("1.0", "end"); output_sha_2.insert("end", h2_sha)

        # Hamming distances
        ham_custom = hamming_distance_bits(h1_custom, h2_custom)
        ham_sha = hamming_distance_bits(h1_sha, h2_sha)
        ham_custom_label.config(text=f"Custom Hash Hamming Distance: {ham_custom} bits")
        ham_sha_label.config(text=f"SHA-256 Hamming Distance: {ham_sha} bits")

    ttk.Button(root, text="Compare Hashes", command=compute_compare).pack(pady=10)
    ttk.Label(root, text="Custom Hash (Toy Algorithm):").pack(pady=3)
    output_custom_1.pack(pady=2)
    output_custom_2.pack(pady=2)
    ham_custom_label.pack(pady=3)

    ttk.Label(root, text="SHA-256 Hash:").pack(pady=3)
    output_sha_1.pack(pady=2)
    output_sha_2.pack(pady=2)
    ham_sha_label.pack(pady=3)

# ==========================================
#  App Start
# ==========================================
root = tk.Tk()
root.title("ðŸ” Custom Hash & Comparison GUI")
root.geometry("1000x750")
root.resizable(False, False)

show_main_menu()
root.mainloop()
import tkinter as tk
from tkinter import ttk, messagebox
import hashlib
import struct

# ==========================================
#  Custom Hash Algorithm (Toy Educational)
# ==========================================
def rotl32(x, r):
    return ((x << r) & 0xFFFFFFFF) | (x >> (32 - r))

def toy_hash(plaintext: str, out_len_hex=32) -> str:
    data = plaintext.encode('utf-8')
    s0, s1, s2, s3 = 0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344
    state = [s0, s1, s2, s3]
    primes = [0x9E3779B1, 0x85EBCA6B, 0xC2B2AE35]
    block_size = 8

    for i in range(0, len(data), block_size):
        block = data[i:i + block_size]
        if len(block) < block_size:
            block = block + b'\x80' + b'\x00' * (block_size - len(block) - 1)
        m0 = struct.unpack_from('<I', block, 0)[0]
        m1 = struct.unpack_from('<I', block, 4)[0]

        state[0] = (state[0] + (m0 ^ primes[0])) & 0xFFFFFFFF
        state[1] = (state[1] ^ (m1 + primes[1])) & 0xFFFFFFFF
        state[2] = (state[2] + rotl32(state[0] ^ m1, 7)) & 0xFFFFFFFF
        state[3] = (state[3] ^ rotl32(state[1] + m0, 11)) & 0xFFFFFFFF
        state[0] ^= ((state[0] << 5) & 0xFFFFFFFF) ^ (state[1] >> 3)
        state[1] = (state[1] + ((state[2] << 7) & 0xFFFFFFFF)) & 0xFFFFFFFF
        state[2] ^= state[3] ^ primes[2]
        state[3] = (state[3] + state[0]) & 0xFFFFFFFF

    for _ in range(6):
        a, b, c, d = state
        a = (a ^ rotl32(b + primes[0], 3) + ((c >> 5) | (d << 27))) & 0xFFFFFFFF
        b = (b + rotl32(c ^ primes[1], 7) ^ ((d << 11) & 0xFFFFFFFF)) & 0xFFFFFFFF
        c = (c ^ rotl32(d + primes[2], 13) + (a >> 2)) & 0xFFFFFFFF
        d = (d + rotl32(a ^ primes[0], 17) ^ (b >> 3)) & 0xFFFFFFFF
        state = [a, b, c, d]

    digest_bytes = b''.join(struct.pack('<I', w) for w in state)
    return digest_bytes.hex()[:out_len_hex]

def hamming_distance_bits(a_hex, b_hex):
    a_bits = bin(int(a_hex, 16))[2:].zfill(len(a_hex) * 4)
    b_bits = bin(int(b_hex, 16))[2:].zfill(len(b_hex) * 4)
    return sum(x != y for x, y in zip(a_bits, b_bits))

# ==========================================
#  GUI: Mode Switching
# ==========================================
def show_main_menu():
    clear_window()
    ttk.Label(root, text="ðŸ” Custom Hash Function Demo", font=("Segoe UI", 16, "bold")).pack(pady=20)
    ttk.Label(root, text="Select an option to continue:", font=("Segoe UI", 12)).pack(pady=10)
    ttk.Button(root, text="ðŸ§© Test Single Hash", command=show_single_hash_ui).pack(pady=10, ipadx=10)
    ttk.Button(root, text="âš–ï¸ Compare Two Hashes", command=show_compare_ui).pack(pady=10, ipadx=10)
    ttk.Label(root, text="(Educational use only â€” not cryptographically secure)", foreground="gray").pack(pady=30)

def clear_window():
    for widget in root.winfo_children():
        widget.destroy()

# ==========================================
#  Mode 1: Single Hash Interface
# ==========================================
def show_single_hash_ui():
    clear_window()
    ttk.Button(root, text="â¬… Back", command=show_main_menu).pack(anchor="nw", padx=10, pady=10)
    ttk.Label(root, text="Single Input Hash Mode", font=("Segoe UI", 15, "bold")).pack(pady=10)

    ttk.Label(root, text="Enter text to hash:").pack(pady=5)
    text_box = tk.Text(root, height=5, width=90)
    text_box.pack(pady=5)

    output_custom = tk.Text(root, height=2, width=90)
    output_sha = tk.Text(root, height=2, width=90)

    def compute_single():
        text = text_box.get("1.0", "end").strip()
        if not text:
            messagebox.showwarning("Empty Input", "Please enter some text!")
            return
        custom_hash = toy_hash(text)
        sha_hash = hashlib.sha256(text.encode()).hexdigest()

        output_custom.delete("1.0", "end")
        output_custom.insert("end", custom_hash)
        output_sha.delete("1.0", "end")
        output_sha.insert("end", sha_hash)

    ttk.Button(root, text="Compute Hash", command=compute_single).pack(pady=10)

    ttk.Label(root, text="Custom Hash (Toy Algorithm):").pack(pady=3)
    output_custom.pack(pady=3)
    ttk.Label(root, text="SHA-256 Hash:").pack(pady=3)
    output_sha.pack(pady=3)

# ==========================================
#  Mode 2: Compare Two Inputs
# ==========================================
def show_compare_ui():
    clear_window()
    ttk.Button(root, text="â¬… Back", command=show_main_menu).pack(anchor="nw", padx=10, pady=10)
    ttk.Label(root, text="Compare Two Inputs", font=("Segoe UI", 15, "bold")).pack(pady=10)

    ttk.Label(root, text="Input Text 1:").pack(pady=5)
    text1 = tk.Text(root, height=4, width=90)
    text1.pack(pady=5)
    ttk.Label(root, text="Input Text 2:").pack(pady=5)
    text2 = tk.Text(root, height=4, width=90)
    text2.pack(pady=5)

    output_custom_1 = tk.Text(root, height=2, width=90)
    output_custom_2 = tk.Text(root, height=2, width=90)
    output_sha_1 = tk.Text(root, height=2, width=90)
    output_sha_2 = tk.Text(root, height=2, width=90)
    ham_custom_label = ttk.Label(root, text="", foreground="blue", font=("Segoe UI", 11, "bold"))
    ham_sha_label = ttk.Label(root, text="", foreground="green", font=("Segoe UI", 11, "bold"))

    def compute_compare():
        t1, t2 = text1.get("1.0", "end").strip(), text2.get("1.0", "end").strip()
        if not t1 or not t2:
            messagebox.showwarning("Empty Input", "Please enter text in both boxes!")
            return

        # Compute hashes
        h1_custom, h2_custom = toy_hash(t1), toy_hash(t2)
        h1_sha, h2_sha = hashlib.sha256(t1.encode()).hexdigest(), hashlib.sha256(t2.encode()).hexdigest()

        # Update outputs
        output_custom_1.delete("1.0", "end"); output_custom_1.insert("end", h1_custom)
        output_custom_2.delete("1.0", "end"); output_custom_2.insert("end", h2_custom)
        output_sha_1.delete("1.0", "end"); output_sha_1.insert("end", h1_sha)
        output_sha_2.delete("1.0", "end"); output_sha_2.insert("end", h2_sha)

        # Hamming distances
        ham_custom = hamming_distance_bits(h1_custom, h2_custom)
        ham_sha = hamming_distance_bits(h1_sha, h2_sha)
        ham_custom_label.config(text=f"Custom Hash Hamming Distance: {ham_custom} bits")
        ham_sha_label.config(text=f"SHA-256 Hamming Distance: {ham_sha} bits")

    ttk.Button(root, text="Compare Hashes", command=compute_compare).pack(pady=10)
    ttk.Label(root, text="Custom Hash (Toy Algorithm):").pack(pady=3)
    output_custom_1.pack(pady=2)
    output_custom_2.pack(pady=2)
    ham_custom_label.pack(pady=3)

    ttk.Label(root, text="SHA-256 Hash:").pack(pady=3)
    output_sha_1.pack(pady=2)
    output_sha_2.pack(pady=2)
    ham_sha_label.pack(pady=3)

# ==========================================
#  App Start
# ==========================================
root = tk.Tk()
root.title("ðŸ” Custom Hash & Comparison GUI")
root.geometry("1000x750")
root.resizable(False, False)

show_main_menu()
root.mainloop()
